import { Game, Table, User, Hand } from '../models/index.js';
import {
  advancePhase,
  checkAllPlayersActed,
  getFirstToActInPhase
} from './game.phases.js';
import { compareHands, getBestHand } from './hand.ranking.js';
import {
  calculateSidePots,
  rebuildSidePots,
  distributeSidePots,
  getActivePlayersCount,
  removeFoldedPlayerFromPots
} from './sidepots.service.js';
import { executeBotTurn } from './bot.ai.js';

// Palos de cartas
const SUITS = ['S', 'H', 'D', 'C'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

/**
 * Crear un mazo nuevo (52 cartas)
 */
export const createDeck = () => {
  const deck = [];
  for (let suit of SUITS) {
    for (let rank of RANKS) {
      deck.push(`${rank}${suit}`);
    }
  }
  // Shuffle
  return shuffleDeck(deck);
};

/**
 * Mezclar el mazo (Fisher-Yates shuffle)
 */
export const shuffleDeck = (deck) => {
  const shuffled = [...deck];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

/**
 * Obtener la siguiente posici칩n del dealer (rotaci칩n circular)
 */
export const getNextDealerPosition = (currentDealerIndex, playersCount) => {
  return (currentDealerIndex + 1) % playersCount;
};

/**
 * Calcular posiciones de dealer, small blind y big blind
 */
export const calculatePositions = (playersArray, dealerIndex) => {
  const count = playersArray.length;
  
  if (count < 2) {
    throw new Error('Se requieren al menos 2 jugadores');
  }

  // En heads-up: dealer = SB, otro = BB
  // En 6-max+: dealer (BTN), siguiente (SB), siguiente (BB)
  let smallBlindIndex, bigBlindIndex;
  
  if (count === 2) {
    // Heads-up solicitado: dealer es BB, otro es SB
    smallBlindIndex = (dealerIndex + 1) % count;
    bigBlindIndex = dealerIndex;
  } else {
    // 6-max+: est치ndar
    smallBlindIndex = (dealerIndex + 1) % count;
    bigBlindIndex = (dealerIndex + 2) % count;
  }

  return {
    dealerIndex,
    smallBlindIndex,
    bigBlindIndex,
    positions: playersArray.map((player, idx) => {
      if (idx === dealerIndex && count > 2) return 'BTN';
      if (idx === smallBlindIndex) return 'SB';
      if (idx === bigBlindIndex) return 'BB';
      if (count === 2) return null;
      
      // Nombres est치ndar para posiciones (6-max):
      // BTN, SB, BB, UTG, HJ, CO
      const positionNames = ['BTN', 'SB', 'BB', 'UTG', 'HJ', 'CO'];
      return positionNames[idx] || `POS${idx}`;
    })
  };
};

/**
 * Inicializar una nueva partida
 */
export const initializeGame = async (tableId, playersData) => {
  try {
    const table = await Table.findByPk(tableId);
    if (!table) throw new Error('Mesa no encontrada');

    const smallBlindAmount = table.smallBlind;
    const bigBlindAmount = table.bigBlind;

    // Crear array de jugadores con estructura
    const players = playersData.map(playerData => ({
      userId: playerData.userId,
      chips: playerData.chips || 1000,
      committed: 0,
      hand: null,
      folded: false,
      isSittingOut: false
    }));

    // Dealer es el primer jugador (ser치 rotado despu칠s de cada mano)
    const dealerIndex = 0;
    const positions = calculatePositions(players, dealerIndex);

    // Crear mazo
    const deck = createDeck();

    // Repartir cartas iniciales (2 por jugador)
    players.forEach(player => {
      player.hand = [deck.pop(), deck.pop()];
      player.holeCards = [...player.hand];
    });

    // El siguiente jugador en turno ser치 quien act칰a primero (despu칠s de BB)
    // En preflop: UTG (after BB)
    // Si es heads-up (2 jugadores): dealer act칰a primero
    const currentPlayerIndex = players.length === 2
      ? positions.smallBlindIndex
      : (positions.bigBlindIndex + 1) % players.length;

    // Crear el juego
    const game = await Game.create({
      tableId,
      phase: 'preflop',
      status: 'active',
      dealerId: players[dealerIndex].userId,
      smallBlindId: players[positions.smallBlindIndex].userId,
      bigBlindId: players[positions.bigBlindIndex].userId,
      players,
      currentPlayerIndex,
      currentBet: bigBlindAmount,
      deck,
      communityCards: [],
      pot: smallBlindAmount + bigBlindAmount
    });

    // Registrar los blinds como apuestas y restarlos de chips
    players[positions.smallBlindIndex].chips -= smallBlindAmount;
    players[positions.smallBlindIndex].committed = smallBlindAmount;
    players[positions.bigBlindIndex].chips -= bigBlindAmount;
    players[positions.bigBlindIndex].committed = bigBlindAmount;

    await game.update({ players });

    return game;
  } catch (error) {
    throw new Error(`Error inicializando juego: ${error.message}`);
  }
};

/**
 * Activar un juego en espera (waiting) con jugadores reales
 */
export const activateWaitingGame = async (game, playersData) => {
  const table = await Table.findByPk(game.tableId);
  if (!table) throw new Error('Mesa no encontrada');

  const smallBlindAmount = table.smallBlind;
  const bigBlindAmount = table.bigBlind;

  const players = playersData.map(playerData => ({
    userId: playerData.userId,
    chips: playerData.chips || 1000,
    committed: 0,
    hand: null,
    folded: false,
    isSittingOut: false,
    lastAction: null,
    betInPhase: 0
  }));

  const dealerIndex = 0;
  const positions = calculatePositions(players, dealerIndex);
  const deck = createDeck();

  players.forEach(player => {
    player.hand = [deck.pop(), deck.pop()];
    player.holeCards = [...player.hand];
  });

  const currentPlayerIndex = players.length === 2
    ? positions.smallBlindIndex
    : (positions.bigBlindIndex + 1) % players.length;

  players[positions.smallBlindIndex].chips -= smallBlindAmount;
  players[positions.smallBlindIndex].committed = smallBlindAmount;
  players[positions.bigBlindIndex].chips -= bigBlindAmount;
  players[positions.bigBlindIndex].committed = bigBlindAmount;

  await game.update({
    phase: 'preflop',
    status: 'active',
    dealerId: players[dealerIndex].userId,
    smallBlindId: players[positions.smallBlindIndex].userId,
    bigBlindId: players[positions.bigBlindIndex].userId,
    players,
    currentPlayerIndex,
    currentBet: bigBlindAmount,
    deck,
    communityCards: [],
    pot: smallBlindAmount + bigBlindAmount
  });

  return game;
};

/**
 * Iniciar una nueva mano en el mismo juego (rotando dealer, SB y BB)
 */
const startNextHand = async (game) => {
  const table = await Table.findByPk(game.tableId);
  if (!table) {
    throw new Error('Mesa no encontrada para nueva mano');
  }

  const smallBlindAmount = table.smallBlind;
  const bigBlindAmount = table.bigBlind;

  const players = JSON.parse(JSON.stringify(game.players || []));

  // Reset estado por jugador
  players.forEach((p) => {
    p.folded = false;
    p.lastAction = null;
    p.betInPhase = 0;
    p.committed = 0;
  });

  // Rotar dealer
  const currentDealerIndex = players.findIndex(p => p.userId === game.dealerId);
  const dealerIndex = getNextDealerPosition(currentDealerIndex >= 0 ? currentDealerIndex : 0, players.length);
  const positions = calculatePositions(players, dealerIndex);

  // Crear mazo y repartir cartas
  const deck = createDeck();
  players.forEach((p) => {
    if (p.chips > 0 && !p.isSittingOut) {
      p.hand = [deck.pop(), deck.pop()];
      p.holeCards = [...p.hand];
      p.folded = false;
    } else {
      p.hand = null;
      p.holeCards = null;
      p.folded = true;
    }
  });

  // Aplicar blinds
  const sbIndex = positions.smallBlindIndex;
  const bbIndex = positions.bigBlindIndex;
  const sbAmount = Math.min(smallBlindAmount, players[sbIndex].chips);
  const bbAmount = Math.min(bigBlindAmount, players[bbIndex].chips);

  players[sbIndex].chips -= sbAmount;
  players[sbIndex].committed = sbAmount;
  players[bbIndex].chips -= bbAmount;
  players[bbIndex].committed = bbAmount;

  const currentPlayerIndex = players.length === 2
    ? dealerIndex
    : (positions.bigBlindIndex + 1) % players.length;

  game.status = 'active';
  game.phase = 'preflop';
  game.dealerId = players[dealerIndex].userId;
  game.smallBlindId = players[sbIndex].userId;
  game.bigBlindId = players[bbIndex].userId;
  game.currentPlayerIndex = currentPlayerIndex;
  game.currentBet = bbAmount;
  game.pot = sbAmount + bbAmount;
  game.communityCards = [];
  game.deck = deck;
  game.sidePots = [];
  game.winnerId = null;
  game.winnerIds = null;
  game.winners = null;
  game.endTime = null;
  game.players = players;
  game.changed('players', true);

  await game.save();
};

/**
 * Repartir cartas comunitarias seg칰n la fase siguiente
 */
const dealCommunityForNextPhase = (game, nextPhase) => {
  // Normalizar deck y community a arrays reales (pueden venir como string JSON desde DB)
  let deck = Array.isArray(game.deck)
    ? [...game.deck]
    : (typeof game.deck === 'string'
        ? JSON.parse(game.deck || '[]')
        : (game.deck ? JSON.parse(JSON.stringify(game.deck)) : []));

  let community = Array.isArray(game.communityCards)
    ? [...game.communityCards]
    : (typeof game.communityCards === 'string'
        ? JSON.parse(game.communityCards || '[]')
        : (game.communityCards ? JSON.parse(JSON.stringify(game.communityCards)) : []));

  const burn = () => {
    if (deck.length === 0) return;
    deck.pop();
  };

  const deal = (count) => {
    for (let i = 0; i < count; i++) {
      if (deck.length === 0) break;
      community.push(deck.pop());
    }
  };

  switch (nextPhase) {
    case 'flop':
      burn();
      deal(3);
      break;
    case 'turn':
      burn();
      deal(1);
      break;
    case 'river':
      burn();
      deal(1);
      break;
    default:
      break;
  }

  game.deck = deck;
  game.communityCards = community;
};

/**
 * Determinar si s칩lo queda un jugador activo
 */
const getActivePlayers = (players) => players.filter(p => !p.folded);

/**
 * Resolver ganador por fold (solo queda uno activo)
 */
const finishByFold = async (game) => {
  const active = getActivePlayers(game.players);
  if (active.length !== 1) return null;

  const winner = active[0];
  const winnerIndex = game.players.findIndex(p => p.userId === winner.userId);

  // Build or rebuild side pots to determine pot distribution
  const sidePots = game.sidePots || calculateSidePots(game.players);

  // Find all pots the winner is eligible for
  let winningsFromPots = 0;
  for (const pot of sidePots) {
    if (pot.eligiblePlayerIndices.includes(winnerIndex)) {
      winningsFromPots += pot.amount;
    }
  }

  // Add the winnings to winner's chips
  winner.chips += winningsFromPots;

  // Actualizar jugadores con el bote distribuido
  game.players = JSON.parse(JSON.stringify(game.players));
  game.changed('players', true);

  // 쮿ay suficientes jugadores con fichas para seguir?
  const playersWithChips = game.players.filter(p => p.chips > 0 && !p.isSittingOut);
  if (playersWithChips.length >= 2) {
    await startNextHand(game);
    return {
      winner: { ...winner, chipsWon: winningsFromPots },
      winners: [{ userId: winner.userId, chipsWon: winningsFromPots }],
      potWon: winningsFromPots,
      handContinues: true
    };
  }

  game.status = 'finished';
  game.winnerId = winner.userId;
  game.pot = 0;
  game.sidePots = sidePots;
  game.endTime = new Date();

  await game.save();

  return {
    winner: { ...winner, chipsWon: winningsFromPots },
    winners: [{ userId: winner.userId, chipsWon: winningsFromPots }],
    potWon: winningsFromPots,
    handContinues: false
  };
};

/**
 * Resolver showdown calculando la mejor mano
 */
const finishShowdown = async (game) => {
  const community = game.communityCards || [];
  const contenders = getActivePlayers(game.players);

  console.log('[DEBUG][SHOWDOWN] Starting showdown...');
  console.log('[DEBUG][SHOWDOWN] Community cards:', community.length, community);
  console.log('[DEBUG][SHOWDOWN] Contenders:', contenders.length);
  console.log('[DEBUG][SHOWDOWN] Pot before distribution:', game.pot);
  console.log('[DEBUG][SHOWDOWN] Side pots:', game.sidePots);

  if (community.length < 5 || contenders.length === 0) {
    console.log('[DEBUG][SHOWDOWN] ERROR: Not enough community cards (', community.length, ') or no contenders (', contenders.length, ')');
    return null;
  }

  // Build side pots
  const sidePots = game.sidePots || calculateSidePots(game.players);
  console.log('[DEBUG][SHOWDOWN] Calculated side pots:', sidePots);

  // Evaluate hands for all contenders
  const handEvals = contenders.map((player) => {
    const playerIndex = game.players.findIndex(p => p.userId === player.userId);
    const bestHand = getBestHand(player.hand, community);
    console.log('[DEBUG][SHOWDOWN] Player', playerIndex, 'hand:', player.hand, 'best:', bestHand);
    return {
      playerIndex,
      player,
      bestHand
    };
  });

  // Distribute each side pot to the best eligible hand
  const distributedPlayers = JSON.parse(JSON.stringify(game.players));
  const dealerIndex = game.players.findIndex(p => p.userId === game.dealerId);
  const numPlayers = game.players.length;
  
  // Track all winners (for split pots)
  const allWinners = new Set();
  const winnerDetails = {};

  for (const pot of sidePots) {
    // Get eligible contenders for this pot
    const potContenders = handEvals.filter(h =>
      pot.eligiblePlayerIndices.includes(h.playerIndex)
    );

    if (potContenders.length === 0) continue;

    // Find best hand(s) among eligible contenders
    let potWinners = [potContenders[0]];
    for (let i = 1; i < potContenders.length; i++) {
      const cmp = compareHands(
        potContenders[i].bestHand,
        potWinners[0].bestHand
      );
      if (cmp === 1) {
        potWinners = [potContenders[i]];
      } else if (cmp === 0) {
        potWinners.push(potContenders[i]);
      }
    }

    // Log split pot winners
    if (potWinners.length > 1) {
      console.log(`[DEBUG][SPLIT_POT] Pot de ${pot.amount} fichas dividido entre ${potWinners.length} ganadores:`, 
        potWinners.map((w, idx) => `${idx}: Player ${w.playerIndex} (${w.player.userId})`).join(', ')
      );
    }

    // Distribute pot among winners
    const share = Math.floor(pot.amount / potWinners.length);
    const remainder = pot.amount - share * potWinners.length;

    // Distribuir share equitativo a todos
    potWinners.forEach((winner) => {
      distributedPlayers[winner.playerIndex].chips += share;
      allWinners.add(winner.player.userId);
      
      // Store winner details
      if (!winnerDetails[winner.player.userId]) {
        winnerDetails[winner.player.userId] = {
          playerIndex: winner.playerIndex,
          userId: winner.player.userId,
          hand: winner.bestHand.hand.name,
          description: winner.bestHand.hand.name,
          chipsWon: share
        };
      } else {
        winnerDetails[winner.player.userId].chipsWon += share;
      }
    });

    // El chip impar va al jugador m치s cercano al dealer en sentido horario
    if (remainder > 0) {
      let closestToDealer = null;
      let closestDistance = numPlayers;

      for (const winner of potWinners) {
        // Calcular distancia en sentido horario desde el dealer
        let distance = (winner.playerIndex - dealerIndex + numPlayers) % numPlayers;
        if (distance === 0 && potWinners.length > 1) {
          distance = numPlayers;
        }
        if (distance < closestDistance) {
          closestDistance = distance;
          closestToDealer = winner.playerIndex;
        }
      }

      if (closestToDealer !== null) {
        distributedPlayers[closestToDealer].chips += remainder;
        winnerDetails[game.players[closestToDealer].userId].chipsWon += remainder;
        console.log(`[DEBUG][CHIP_ODD] Chip impar (${remainder}) asignado a player ${closestToDealer} (distancia: ${closestDistance} desde dealer ${dealerIndex})`);
      }
    }
  }

  // Get primary winner and all winners info
  const primaryWinner = distributedPlayers.find(p => p.userId === contenders[0].userId);
  const winners = Array.from(allWinners).map(userId => {
    const user = game.players.find(p => p.userId === userId);
    const details = winnerDetails[userId];
    return {
      userId,
      username: user?.username || 'Unknown',
      chips: distributedPlayers.find(p => p.userId === userId)?.chips || 0,
      hand: details?.hand,
      description: details?.description,
      chipsWon: details?.chipsWon || 0
    };
  });

  console.log('[DEBUG][WINNERS] All winners:', winners.map(w => `${w.username} (${w.chipsWon} chips)`).join(', '));

  // Actualizar jugadores con chips distribuidos
  game.players = distributedPlayers;
  game.changed('players', true);

  // 쮿ay suficientes jugadores con fichas para seguir?
  const playersWithChips = game.players.filter(p => p.chips > 0 && !p.isSittingOut);
  if (playersWithChips.length >= 2) {
    const potWon = winners.reduce((sum, w) => sum + (w.chipsWon || 0), 0);
    await startNextHand(game);
    return { winner: primaryWinner, winners, potWon, handContinues: true };
  }

  game.status = 'finished';
  game.phase = 'showdown';
  game.winnerId = primaryWinner.userId;
  game.winnerIds = Array.from(allWinners);
  game.winners = winners;
  game.pot = 0;
  game.sidePots = sidePots;
  game.endTime = new Date();

  await game.save();

  return { winner: primaryWinner, handContinues: false };
};

/**
 * Avanzar a la siguiente fase si corresponde
 */
const advanceGamePhase = async (game) => {
  const nextPhase = advancePhase(game.phase);

  if (!nextPhase) {
    return await finishShowdown(game);
  }

  dealCommunityForNextPhase(game, nextPhase);

  // Reset de apuestas para la nueva ronda (deep copy de players)
  game.currentBet = 0;
  const players = JSON.parse(JSON.stringify(game.players));
  
  // IMPORTANTE: Mantener committed para calcular side pots
  // Solo resetear lastAction y betInPhase
  players.forEach((p) => {
    p.lastAction = null;
    p.betInPhase = 0;
    // NO resetear p.committed - lo necesitamos para side pots
  });
  game.players = players;

  const dealerIndex = game.players.findIndex(p => p.userId === game.dealerId);
  const firstToAct = getFirstToActInPhase(game.players, dealerIndex, nextPhase);

  game.phase = nextPhase;
  game.currentPlayerIndex = firstToAct;

  console.log('[DEBUG][ADVANCE_PHASE] Avanzando a', nextPhase, 'pot:', game.pot, 'committed:', players.map(p => p.committed));

  await game.update({
    phase: game.phase,
    communityCards: JSON.stringify(game.communityCards),
    deck: JSON.stringify(game.deck),
    players: game.players,
    currentBet: 0,
    pot: game.pot,
    currentPlayerIndex: game.currentPlayerIndex
  });

  return;

  return null;
};

/**
 * Validar que una acci칩n es legal
 */
export const validateAction = (game, playerId, action, amount = 0) => {
  const players = game.players;
  const currentPlayerIndex = game.currentPlayerIndex;
  const currentPlayer = players[currentPlayerIndex];

  // Verificar que es el turno del jugador
  if (currentPlayer.userId !== playerId) {
    throw new Error('No es tu turno');
  }

  // Verificar que el jugador no est치 folded
  if (currentPlayer.folded) {
    throw new Error('Ya hiciste fold en esta mano');
  }

  // Convertir a n칰meros para evitar comparaciones de strings
  const currentBet = parseInt(game.currentBet) || 0;
  const playerChips = currentPlayer.chips;
  const playerCommitted = parseInt(currentPlayer.committed) || 0;

  switch (action) {
    case 'fold':
      return true;

    case 'check':
      // Solo si la apuesta actual es igual a lo que ya ha puesto
      if (playerCommitted >= currentBet) {
        return true;
      }
      throw new Error('No puedes hacer check, necesitas igualar la apuesta');

    case 'call':
      const callAmount = currentBet - playerCommitted;
      if (callAmount > playerChips) {
        throw new Error('No tienes suficientes fichas para igualar');
      }
      return true;

    case 'raise':
      // Si el jugador est치 haciendo all-in (apostando todas sus fichas), es v치lido
      const isAllIn = amount >= playerChips;
      
      if (!isAllIn && amount <= currentBet - playerCommitted) {
        throw new Error(`La subida m칤nima es ${currentBet - playerCommitted + currentBet}`);
      }
      const raiseTotal = playerCommitted + amount;
      if (raiseTotal > playerChips + playerCommitted) {
        throw new Error('No tienes suficientes fichas para subir esa cantidad');
      }
      return true;

    case 'all-in':
      if (playerChips <= 0) {
        throw new Error('Ya est치s all-in');
      }
      return true;

    default:
      throw new Error('Acci칩n inv치lida');
  }
};

/**
 * Procesar una acci칩n en el juego
 */
export const processPlayerAction = async (game, playerId, action, amount = 0) => {
  // Asegurar que pot y currentBet son n칰meros ANTES de validar
  game.pot = parseInt(game.pot) || 0;
  game.currentBet = parseInt(game.currentBet) || 0;

  // Tambi칠n convertir committed de todos los jugadores
  game.players.forEach(p => {
    p.committed = parseInt(p.committed) || 0;
  });

  validateAction(game, playerId, action, amount);

  const players = game.players;
  const currentPlayerIndex = game.currentPlayerIndex;
  const currentPlayer = players[currentPlayerIndex];

  let totalBet = 0;

  switch (action) {
    case 'fold':
      currentPlayer.folded = true;
      // Rebuild side pots when a player folds
      if (!game.sidePots) {
        game.sidePots = calculateSidePots(game.players);
      }
      game.sidePots = removeFoldedPlayerFromPots(game.sidePots, currentPlayerIndex);
      break;

    case 'check':
      // No hay cambio en fichas
      break;

    case 'call':
      const playerCommittedNum = parseInt(currentPlayer.committed) || 0;
      const callAmount = game.currentBet - playerCommittedNum;
      currentPlayer.chips -= callAmount;
      currentPlayer.committed = playerCommittedNum + callAmount;
      game.pot += callAmount;
      totalBet = callAmount;
      break;

    case 'raise':
      // Si el jugador est치 apostando todas sus fichas (all-in), manejarlo como tal
      if (amount >= currentPlayer.chips) {
        // Es un all-in disfrazado de raise
        totalBet = currentPlayer.chips;
        game.pot += currentPlayer.chips;
        currentPlayer.committed = (parseInt(currentPlayer.committed) || 0) + currentPlayer.chips;
        currentPlayer.chips = 0;
        // Solo actualizar currentBet si la nueva apuesta es mayor
        if (currentPlayer.committed > game.currentBet) {
          game.currentBet = currentPlayer.committed;
        }
      } else {
        // Raise normal
        currentPlayer.chips -= amount;
        currentPlayer.committed = (parseInt(currentPlayer.committed) || 0) + amount;
        game.pot += amount;
        game.currentBet = currentPlayer.committed;
        totalBet = amount;
      }
      break;

    case 'all-in':
      totalBet = currentPlayer.chips;
      game.pot += currentPlayer.chips;
      currentPlayer.committed = (parseInt(currentPlayer.committed) || 0) + currentPlayer.chips;
      currentPlayer.chips = 0;
      if (currentPlayer.committed > game.currentBet) {
        game.currentBet = currentPlayer.committed;
      }
      // Initialize side pots when a player goes all-in
      if (!game.sidePots) {
        game.sidePots = calculateSidePots(game.players);
      }
      break;
  }

  currentPlayer.lastAction = action;
  currentPlayer.betInPhase = (currentPlayer.betInPhase || 0) + totalBet;

  // Normalizar referencia expl칤citamente (algunas implementaciones de JSON pueden entregar copias)
  players[currentPlayerIndex] = { ...currentPlayer };

  console.log('[DEBUG][NEXT_PLAYER] After action, looking for next player');
  console.log('[DEBUG][NEXT_PLAYER] Current player index:', currentPlayerIndex);
  console.log('[DEBUG][NEXT_PLAYER] Players state:', players.map((p, idx) => ({
    index: idx,
    userId: p.userId,
    chips: p.chips,
    folded: p.folded
  })));

  // Mover al siguiente jugador que no est치 folded NI all-in
  let nextIndex = (currentPlayerIndex + 1) % players.length;
  const startIndex = nextIndex;

  console.log('[DEBUG][NEXT_PLAYER] Starting nextIndex:', nextIndex, 'startIndex:', startIndex);

  // Saltar jugadores folded o all-in (sin chips para actuar)
  while (players[nextIndex].folded || players[nextIndex].chips === 0) {
    console.log('[DEBUG][NEXT_PLAYER] Skipping player', nextIndex, '- folded:', players[nextIndex].folded, 'chips:', players[nextIndex].chips);
    nextIndex = (nextIndex + 1) % players.length;
    if (nextIndex === startIndex) {
      console.log('[DEBUG][NEXT_PLAYER] Full circle! nextIndex === startIndex');
      // Todos excepto uno han hecho fold, o todos est치n all-in
      const activePlayers = getActivePlayers(players);
      if (activePlayers.length === 1) {
        console.log('[DEBUG][NEXT_PLAYER] Only 1 active player, ending by fold');
        const foldResult = await finishByFold(game);
        if (foldResult?.handContinues) {
          return {
            success: true,
            handOver: true,
            winner: foldResult.winner,
            gameState: await getGameState(game.id, false)
          };
        }
        return { gameOver: true, winner: foldResult?.winner || foldResult };
      }
      // Todos est치n all-in, avanzar a la siguiente fase autom치ticamente
      console.log('[DEBUG][NEXT_PLAYER] All players all-in, breaking');
      break;
    }
  }

  console.log('[DEBUG][NEXT_PLAYER] Found next player:', nextIndex);

  // Verificar si la ronda de apuestas termin칩
  const dealerIndex = players.findIndex(p => p.userId === game.dealerId);
  const firstToAct = getFirstToActInPhase(players, dealerIndex, game.phase);
  const activePlayers = getActivePlayers(players);

  let roundComplete = checkAllPlayersActed(players, dealerIndex);

  // Debug: estado antes de decidir avanzar de fase
  console.log('[DEBUG][ROUND_CHECK]', {
    phase: game.phase,
    currentBet: game.currentBet,
    dealerIndex,
    firstToAct,
    currentPlayerIndex,
    nextIndex,
    roundComplete,
    activePlayers: activePlayers.map(p => ({
      userId: p.userId,
      committed: parseInt(p.committed) || 0,
      chips: p.chips,
      lastAction: p.lastAction,
      betInPhase: p.betInPhase || 0,
      folded: p.folded
    }))
  });

  // Fallback: si todos actuaron, las apuestas est치n igualadas
  // y volvimos al primer jugador de la fase, cerramos la ronda.
  if (!roundComplete) {
    const currentBetNum = parseInt(game.currentBet) || 0;
    // Solo considerar jugadores que pueden actuar (tienen chips)
    const playersWithChips = activePlayers.filter(p => p.chips > 0);
    
    const allMatched = playersWithChips.every(p => {
      const committed = parseInt(p.committed) || 0;
      return committed >= currentBetNum;
    });
    const everyoneActed = playersWithChips.every(p => p.lastAction);

    if (everyoneActed && allMatched && nextIndex === firstToAct) {
      roundComplete = true;
    }
  }

  if (activePlayers.length === 1) {
    const foldResult = await finishByFold(game);
    if (foldResult?.handContinues) {
      return {
        success: true,
        handOver: true,
        winner: foldResult.winner,
        gameState: await getGameState(game.id, false)
      };
    }
    return { gameOver: true, winner: foldResult?.winner || foldResult };
  }

  if (roundComplete) {
    console.log('[DEBUG][ROUND_COMPLETE] Round marked as complete');
    console.log('[DEBUG][ROUND_COMPLETE] Players:', players.map(p => ({
      userId: p.userId,
      chips: p.chips,
      committed: p.committed,
      lastAction: p.lastAction,
      folded: p.folded
    })));
    
    // Deep copy limpio para guardar
    game.players = JSON.parse(JSON.stringify(players));
    game.changed('players', true);
    
    // Guardar el estado actualizado antes de avanzar fase
    await game.save();
    console.log(`[DEBUG][SAVE] Game ${game.id} saved with ${game.players?.length || 0} players`);

    const activePlayers = players.filter(p => !p.folded);
    const playersWithChips = activePlayers.filter(p => p.chips > 0);

    console.log('[DEBUG][ROUND_COMPLETE] Active players:', activePlayers.length);
    console.log('[DEBUG][ROUND_COMPLETE] Players with chips:', playersWithChips.length);

    // Si solo queda 1 jugador con fichas y hay al menos 2 activos, saltar directo hasta showdown
    if (playersWithChips.length <= 1 && activePlayers.length > 1) {
      // IMPORTANTE: No hacer el showdown aqu칤 dentro de processPlayerAction
      // Solo retornar el estado actual con el pot actualizado.
      // El cliente podr치 consultar de nuevo o el showdown ocurrir치 autom치ticamente en la siguiente consulta
      return {
        phaseAdvanced: true,
        gameState: await getGameState(game.id, false)
      };
    }

    // Flujo normal: avanzar solo una fase
    if (game.phase === 'river') {
      const showdownResult = await finishShowdown(game);
      if (showdownResult?.handContinues) {
        return {
          success: true,
          handOver: true,
          winner: showdownResult.winner,
          gameState: await getGameState(game.id, false)
        };
      }
      return { gameOver: true, winner: showdownResult?.winner || showdownResult };
    }

    await advanceGamePhase(game);
    
    const result = {
      phaseAdvanced: true,
      gameState: await getGameState(game.id, false)
    };

    // Check if next player is a bot after phase advance
    try {
      const nextPlayerIndex = game.currentPlayerIndex;
      const nextPlayer = game.players[nextPlayerIndex];
      if (nextPlayer) {
        const nextUser = await User.findByPk(nextPlayer.userId);
        
        if (nextUser?.isBot && game.status === 'active') {
          console.log(`[BOT] Auto-executing turn for bot: ${nextUser.username} (after phase advance)`);
          // Execute bot turn with 1 second delay
          setTimeout(async () => {
            try {
              await executeBotTurn(game.id);
            } catch (botError) {
              console.error('[BOT] Error executing bot turn:', botError.message);
            }
          }, 1000);
        }
      }
    } catch (botCheckError) {
      console.error('[BOT] Error checking if next player is bot:', botCheckError.message);
    }

    return result;
  }

  // Si no pasamos la ronda completa, simplemente mover al siguiente jugador
  game.currentPlayerIndex = nextIndex;
  game.players = JSON.parse(JSON.stringify(players));  // Deep copy limpio
  game.changed('players', true);
  
  await game.save();

  const result = { 
    success: true, 
    action, 
    amount: totalBet,
    nextPlayer: players[nextIndex],
    gameState: await getGameState(game.id, false)
  };

  // Check if next player is a bot and execute automatically
  try {
    const nextPlayer = players[nextIndex];
    const nextUser = await User.findByPk(nextPlayer.userId);
    
    console.log(`[DEBUG] Siguiente jugador: ${nextUser?.username}, isBot: ${nextUser?.isBot}`);
    
    if (nextUser?.isBot && game.status === 'active') {
      console.log(`[BOT] Auto-executing turn for bot: ${nextUser.username}`);
      // Execute bot turn with 1 second delay
      setTimeout(async () => {
        try {
          console.log(`[BOT] Ejecutando ejecuteBotTurn para ${nextUser.username}`);
          await executeBotTurn(game.id);
        } catch (botError) {
          console.error('[BOT] Error executing bot turn:', botError.message);
        }
      }, 1000);
    } else {
      console.log(`[DEBUG] No es bot o juego no activo. isBot: ${nextUser?.isBot}, status: ${game.status}`);
    }
  } catch (botCheckError) {
    console.error('[BOT] Error checking if next player is bot:', botCheckError.message);
  }

  return result;
};

/**
 * Obtener el estado actual del juego
 */
export const getGameState = async (gameId, autoShowdown = true) => {
  const game = await Game.findByPk(gameId, {
    include: [
      {
        model: Table,
        attributes: ['name', 'smallBlind', 'bigBlind', 'maxPlayers']
      },
      {
        model: User,
        as: 'winner',
        attributes: ['id', 'username', 'avatar']
      }
    ]
  });

  if (!game) throw new Error('Juego no encontrado');

  console.log(`[DEBUG][getGameState] Game ${gameId}:`, {
    players_count: game.players?.length || 0,
    players_raw: game.players,
    status: game.status,
    phase: game.phase
  });

  // Si el juego est치 activo y todos excepto 1 jugador est치n all-in, hacer showdown autom치ticamente
  // PERO solo si autoShowdown es true (no se ejecuta durante processPlayerAction)
  if (autoShowdown && game.status === 'active') {
    const activePlayers = game.players.filter(p => !p.folded);
    const playersWithChips = activePlayers.filter(p => p.chips > 0);

    if (playersWithChips.length <= 1 && activePlayers.length > 1 && game.phase !== 'showdown') {
      // Avanzar autom치ticamente a river si no estamos all칤
      while (game.phase !== 'river') {
        console.log('[DEBUG][GAMESTATE_AUTO] Avanzando de', game.phase);
        await advanceGamePhase(game);
      }
      // Hacer showdown
      console.log('[DEBUG][GAMESTATE_AUTO] Haciendo showdown');
      await finishShowdown(game);
    }
  }

  // Parse JSON fields si son strings
  const communityCards = typeof game.communityCards === 'string' 
    ? JSON.parse(game.communityCards || '[]')
    : (game.communityCards || []);

  // Obtener informaci칩n completa de los jugadores desde la base de datos
  const playerUserIds = game.players.map(p => p.userId);
  const users = await User.findAll({
    where: { id: playerUserIds },
    attributes: ['id', 'username', 'avatar', 'chips']
  });

  // Crear un mapa de usuarios por ID para b칰squeda r치pida
  const usersMap = {};
  users.forEach(u => {
    usersMap[u.id] = u;
  });

  return {
    id: game.id,
    tableId: game.tableId,
    table: game.Table,
    phase: game.phase,
    status: game.status,
    pot: parseInt(game.pot) || 0,
    communityCards: communityCards,
    currentBet: parseInt(game.currentBet) || 0,
    currentPlayerIndex: game.currentPlayerIndex,
    players: game.players.map((p, idx) => {
      const user = usersMap[p.userId];
      return {
        userId: p.userId,
        username: user?.username || 'Unknown',
        avatar: user?.avatar || '游꿡',
        chips: p.chips,
        committed: parseInt(p.committed) || 0,
        folded: p.folded,
        lastAction: p.lastAction || null,
        betInPhase: p.betInPhase || 0,
        isCurrentPlayer: idx === game.currentPlayerIndex,
        holeCards: p.holeCards || [],
        cardsHidden: true // Las cartas se ven seg칰n permisos
      };
    }),
    dealerIndex: game.players.findIndex(p => p.userId === game.dealerId),
    smallBlindIndex: game.players.findIndex(p => p.userId === game.smallBlindId),
    bigBlindIndex: game.players.findIndex(p => p.userId === game.bigBlindId),
    winner: game.winner || null,
    winners: game.winners || [],
    winnerIds: game.winnerIds || [],
    startTime: game.startTime,
    endTime: game.endTime
  };
};

export default {
  createDeck,
  shuffleDeck,
  getNextDealerPosition,
  calculatePositions,
  initializeGame,
  validateAction,
  processPlayerAction,
  getGameState
};
